
= {lab_name}
:navtitle: Narrative
:imagesdir: ../assets/images
:numbered:


[.text-justify]
== 事件驅動的智慧維運 實機工作坊

image::demo_access_details.png[Access Details, 60%]

== Event-Driven Ansible

=== Demo Introduction

在本次示範中，我們將展示 Event-Driven Ansible 的適應性與高效性。雖然這裡使用的是 OpenShift 事件作為觸發條件，但請務必強調，這項工具的能力並不侷限於 OpenShift，它的設計能夠有效運作於任何客戶所擁有的營運生態系統。

展示 Event-Driven Ansible 如何利用事件來啟動動作，說明它能將任何事件轉化為智慧化自動化的契機。這不只是自動化，而是一套高效率、以事件驅動的回應系統，並能與任何營運環境相容。

透過真實案例，說明此工具如何優化流程，使其更高效、更快速且更具回應性。到示範結束時，客戶應能理解，在當今快速演變的數位環境中，採用 Event-Driven Ansible 能為營運帶來的競爭優勢與敏捷性。


=== The Power of Event-Driven Ansible
Event-Driven Ansible 融合了 Ansible 的多功能性與事件驅動架構的原則，使其成為任何營運生態系統的重要資產。

在此示範中，您將會了解 Event-Driven Ansible 如何不僅能管理應用程式部署與擴充，還能用於日常任務和快速疑難排解。這個平台能將自動化高效地轉變為涵蓋整個生態系統的快速、主動回應機制，並可根據客戶特定的業務需求進行調整。

透過運用 Event-Driven Ansible，您可以顯著提升客戶的基礎設施復原時間。每當問題發生時，系統會自動觸發預定義的回應，減少手動診斷和解決問題所花費的時間。這種自動化不僅加速復原，也將疑難排解過程中因人為錯誤所帶來的風險降至最低。

此外，Event-Driven Ansible 也能幫助簡化並自動化常規任務。這讓您的客戶能夠專注於策略性專案，而不被日常營運所拖累。舉凡系統更新、使用者管理和日常維護等任務都能自動化，從而節省寶貴的時間與資源。

在示範期間，您將提供一個清晰的理解，說明 Event-Driven Ansible 如何幫助實現高效、智慧且具回應性的自動化。這不僅有助於快速解決問題與基礎設施復原，也能有效地管理日常營運。藉由展示這些能力，您可以強調 Event-Driven Ansible 在其組織中廣泛的好處與潛在應用，進而提升其營運效率與生產力。


== Understanding Rulebooks

=== The Backbone of Event Driven Ansible

*'Rulebooks'* 是我們今天示範的核心。在 Event-Driven Ansible 的情境中，rulebook 定義了 Ansible 應該如何回應特定事件或狀況的準則。

rulebook 是我們的策略藍圖，由三個基本組成部分構成：

* *Sources:* Rulebook 自動化流程的起點是 sources，用於定義我們所使用的事件來源。這些來源取自各種來源外掛程式 (source plugins)，專為應對各式使用情境所打造。隨著我們持續擴展產品組合，將會有更多來源可供選擇。目前，我們已有多個隨時可用的外掛程式，包括 webhooks、Kafka、Azure service bus、檔案變更監控，以及 alertmanager。

* *Rules:* 擔任決策者的角色，rules 負責設定我們在選定的事件來源中尋找的條件。如果某個條件被滿足，它就能觸發後續的動作，在我們的自動化鏈中形成關鍵的連結。

* *Actions:* 這項流程的最終環節，actions 決定了當條件滿足時應執行的動作。目前可用的動作類型多樣，例如 run_playbook、run_module、set_fact、post_event 與 debug。

因此，這份 rulebook 為您的自動化流程提供了全面、可客製化且可擴充的藍圖，確保我們涵蓋了從事件來源到回應動作的整個環節。

=== The Business Benefits of Event-Driven Ansible
在本次示範中，我們將深入探討導入 Event-Driven Ansible 後，您可以實現的眾多業務效益：

*Real-Time Responsiveness:* 自動化回應事件，進而實現更快速的問題解決與更佳的資源利用率。

* *Increased Efficiency:* 減少手動任務、降低錯誤，並提升營運生產力。

* *Scalability and Flexibility:* 拓展您的自動化能力，使其與您的基礎設施同步，實現對多變環境的無縫適應。

* *Intelligent Automation:* 利用事件資料做出明智的決策，從而最佳化資源使用。

* *Enhanced Reliability:* 確保任務執行的一致性與準確性，從而降低與人為錯誤相關的風險。

* *Improved Compliance and Governance:* 強制執行標準、追蹤自動化動作，並證明其合規性。

* *Rapid Innovation and Time-to-Market:* 加速服務交付與應用程式部署，以更迅速地回應市場趨勢。

與既有系統整合：與您現有的工具、系統及 API 進行無縫整合。

=== Conclusion: The Transformative Potential of Event-Driven Ansible

本次示範中，您將會看到 Event-Driven Ansible 如何作為催化劑，釋放前所未有的自動化潛力，在任何營運環境中提升效率、擴展性與可靠性。現在，準備好深入探索下一世代的自動化技術吧。

== Architecture

=== High Level Infrastructure Architecture

image::event_driven_ansible_architecture.jpg[Event-Driven Ansible Architecture, 50%]


== Demo 指南

.Demo 指南
[width=100%,cols="^.5%,30%a,65%a",options="header"]
|====
| SR No ^.^| Say ^.^| Do

|{counter:srn}|
[.text-justify]
=== Lab 1 - EDA apply resource quota on namespace
[.text-justify]
若要進行示範，我們需要開啟數個瀏覽器分頁，分別用於：-

* Vscode server 
* Ansible Automation Platform
** Automation Controller
** Event Driven Ansible
* [Optional] OpenShift Console

[.text-justify]
*demo.redhat.com* Info page contains all of the access details.

|*Action:*
[.text-justify]
.  請前往資訊頁面，點擊 VS Code Server 連結，並使用表格中提供的密碼登入。

+
image:vscode_login.jpg[VScode Login page, 95%]

.  請前往資訊頁面，點擊 Ansible Automation Platform 連結，並使用表格中提供的帳號與密碼登入。

+
NOTE: 有時候直接複製貼上密碼可能無法成功。如果您無法登入，請嘗試手動逐字輸入密碼，這或許能解決問題。

+
image:ac_login.jpg[Automation Controller Login page, 95%]


.  [Optionally] 請前往資訊頁面，點擊 OpenShift Console 連結，並使用表格中提供的帳號與密碼登入。
+
.Click htpasswd_provider
image:oc_login_1.jpg[OpenShift Login page, 95%]
+
.Login
image:oc_login_2.jpg[OpenShift Login page, 95%]



|{counter:srn}|
[.text-justify]
登入 Ansible Automation Platform 以監控工作和觸發的事件。
|*Action:*
[.text-justify]
.  請前往「自動化執行 (Automation Controller)」，點擊「工作 (Jobs)」。工作區段將顯示由 Event-driven Ansible 觸發的所有工作範本狀態。
+
image:ac_jobs.jpg[Automation Controller Jobs, 95%]


.  請前往「自動化決策 (Event Driven Ansible)」，點擊「Rulebook 啟用 (Rulebook Activations)」。此區段將顯示所有 Rulebook 的啟用狀態。
+
image:eda_rulebook_activations_v2.png[Event-Driven Ansible Controller Rulebooks, 95%]


|{counter:srn}|
[.text-justify]
為了準備 VS Code Server 主控台來建立 OpenShift 資源並觸發 Event-driven Ansible rulebooks，請執行以下操作：

|*Action:*
[.text-justify]
.  請回到 VS Code Server 主控台並開啟一個終端機。
+
image:vscode_login_terminal.jpg[VScode terminal, 95%]

|{counter:srn}|
[.text-justify]
為了透過 Event-driven Ansible 事件，針對新的命名空間（rocketchat）觸發設定資源配額，請遵循以下步驟：

[.text-justify]
接下來，我們前往 VS Code Server 的整合式終端機，然後切換到 test-events 目錄。這個目錄中包含了三個 YAML 檔案，它們定義了 OpenShift 物件。

[.text-justify]
為了觸發資源配額設定，我們將使用 oc 指令搭配 1-test-resource-quota-on-namespace.yml 檔案，在 OpenShift 中建立 rocketchat 命名空間。

[.text-justify]
命名空間建立最終將觸發一個「設定資源配額」事件。作為此事件的動作，它將會在已建立的 rocketchat 命名空間上設定資源配額。
 
[.text-justify]
為了觀察結果，我們可以檢查「自動化決策 (Event Driven Ansible)」中的 Rulebook 啟用狀態，以及「自動化執行 (Automation Controller)」中的工作。

[.text-justify]
您可以執行 OpenShift 的 oc 命令列工具，來驗證 rocketchat 命名空間上的資源配額變更。

|*Action:*
[.text-justify]
.  請前往 VS Code 整合式終端機，切換目錄並執行 oc 指令，以建立命名空間 rocketchat，此動作最終會觸發事件。

+
[source,shell]
----
cd $HOME/demo/test-events/
oc create -f 1-test-resource-quota-on-namespace.yml
----

+
image:eda_vscode_terminal.jpg[VScode terminal, 100%]

*Observe:*
[.text-justify]
. 觀察「自動化決策 (Event Driven Ansible)」中的「設定命名空間資源配額 Rulebook 啟用」，它已經捕捉到新命名空間的事件並觸發了相應的動作。



// . Click on Set Resource Quota on Namespace Rulebook Activation.

+
image:eda_trigger_1.jpg[Rulebook Trigger, 95%]

// . Click on History.

// +
// image:eda_trigger_2.jpg[Rulebook Trigger, 95%]

// . Now click on Set Resource Quota on Namespace to view the EDA event logs.
// +
// image:eda_trigger_3.jpg[Rulebook Trigger, 95%]

. 觀察「自動化執行 (Automation Controller)」，您會看到一個新的工作正在執行。
+
image:rq_ac_job.jpg[Automation Controller Job, 95%]


. 觀察到新的命名空間 rocketchat 已設定配額。請在第二個終端機中執行以下指令。

+
[source,shell]
----
oc get resourcequota -n rocketchat
----



|{counter:srn}|
[.text-justify]
=== Lab 2 - EDA create volume snapshot on pvc
[.text-justify]
為了透過 Event-driven Ansible 事件，針對新加入的 PVC 觸發建立磁碟區快照，請執行以下步驟.

[.text-justify]
請前往終端機，並確認您仍然在 test-events 目錄中。這個目錄包含了三個 OpenShift 物件定義的 YAML 檔案。

[.text-justify]
為了觸發建立磁碟區快照，我們將使用 oc 指令搭配 2-test-volume-snapshot.yml 檔案，在 rocketchat 命名空間中建立 rocketchat 應用程式、資料庫及持久性磁碟區請求 (PVC)。

[.text-justify]
新建立的persistentvolumeclaim (PVC) 最終將會觸發「建立磁碟區快照」事件。作為此事件的動作，它會在 rocketchat 命名空間中為該persistentvolumeclaim建立一個快照。
 
[.text-justify]
為了觀察結果，我們可以檢查「自動化決策 (Event Driven Ansible)」中的 Rulebook 啟用狀態，以及「自動化執行 (Automation Controller)」中的工作。

[.text-justify]
為了驗證變更，請執行 OpenShift oc 指令，以取得 rocketchat 命名空間中的磁碟區快照列表。

|*Action:*
[.text-justify]
.  請前往 VS Code 終端機，切換目錄並執行 oc 指令，在 rocketchat 命名空間中建立 rocketchat 應用程式，此動作最終會觸發事件。
+
[source,shell]
----
cd $HOME/demo/test-events/
oc create -f 2-test-volume-snapshot.yml
----


*Observe:*
[.text-justify]
.   觀察 Automation Decision (Event Driven Ansible) 中的 Create Volume Snapshot Rulebook Activation，它已捕捉到新 persistentvolumeclaim 的事件並觸發了相應的動作。

.  觀察 Automation Execution (Automation Controller)，您會看到一個新的 job 正在執行。

.  觀察到新的 persistentvolumeclaim 在 rocketchat namespace 中已建立 snapshot。請在第二個 terminal 中執行以下指令。
+
[source,shell]
----
oc get volumesnapshot -n rocketchat
----


|{counter:srn}|

[.text-justify]
=== Lab 3 - EDA patch route with cert
[.text-justify]
為了透過 Event-driven Ansible 事件，針對新加入的 route 觸發 patch，請執行以下操作：
[.text-justify]
請前往 terminal，並確保您仍在 test-events 目錄中，此目錄包含了三個定義 OpenShift 物件的 YAML 檔案。
[.text-justify]
為了觸發 patch route，我們將使用 oc 指令搭配 3-test-route-with-cert.yml 檔案，在 rocketchat namespace 中為 rocketchat 應用程式建立一個 route。
[.text-justify]
新建立的 route 最終將會觸發一個 patch route 事件。作為此事件的 action，它會使用已簽署的憑證來對 rocketchat namespace 中的該 route 進行 patch。
[.text-justify]
為了觀察結果，我們可以檢查 Automation Decision (Event Driven Ansible) 中的 Rulebook Activate 歷史記錄，以及 Automation Execution (Automation Controller) 中的 jobs。

[.text-justify]
為了驗證變更，請執行 OpenShift oc 指令，以取得 rocketchat namespace 中的 route。


|*Action:*
[.text-justify]
.  請前往 VS Code terminal，切換目錄並執行 oc 指令，在 rocketchat namespace 中為 rocketchat 應用程式建立 route，此動作最終會觸發事件。

+
[source,shell]
----
cd $HOME/demo/test-events/
oc create -f 3-test-route-with-cert.yml
----


*Observe:* 
[.text-justify]
. 觀察 Automation Decision (Event Driven Ansible) 中的 Patch Route With Cert Rulebook Activation，它已捕捉到新 route 的事件並觸發了相應的 action。

. 觀察 Automation Execution (Automation Controller)，您會看到一個新的 job 正在執行。

. 觀察到新的 route 已經使用憑證進行了 patch。請在 terminal 上執行以下指令。

+
[source,shell]
----
oc get route -n rocketchat -o yaml \| grep cert-manager
----


|{counter:srn}|
[.text-justify]
=== Lab 4 - EDA oc adm inspect
[.text-justify]
我們現在將建立一個新任務，讓 Event-driven Ansible 能夠觸發新的動作。
當發生警告（Warning）或非健康（Unhealthy）事件時，將觸發 EDA 去收集一份 inspect 檔案，以供後續調查使用。

首先必須只定一台機器作為執行oc指令的主機，因此需要在AAP加入此機器的相關設定。
** 如果在上一場workshop中已經建立過bastion主機的Inventory，且名稱為bastion，則可以跳到步驟內的Create Host Group**


|*Action:*
[.text-justify]
要在 Ansible Automation Platform (AAP) 中建立一個新的 inventory，以新增執行 oc 指令的機器，請按照以下步驟操作：

image:aap_add_inventory.jpg[Create Inventory, 95%]

image:aap_add_inventory2.png[Create Inventory, 95%]

Add host in the inventory

image:https://hackmd.io/_uploads/Hyh6HRf_ee.jpg[]

image:https://hackmd.io/_uploads/B1WhGvtJT.png[]

image:https://hackmd.io/_uploads/H1pIbPY1a.png[]

Create credential for bastion
**如果在上一場workshop中已經建立過bastion主機的Credential，且名稱為bastion，則可以跳過**

image:https://hackmd.io/_uploads/BJnZUCzOee.jpgp[]
image:https://hackmd.io/_uploads/SyojI0M_ge.jpg[]

Create Host group in bastion inventory and add bastion to the host group

image:https://hackmd.io/_uploads/BJ175QXdel.png[]
image:https://hackmd.io/_uploads/BJBRDX7Oel.png[]
image:https://hackmd.io/_uploads/BkEm_7m_ex.png[]
image:https://hackmd.io/_uploads/r1SsdX7_ge.png[]
image:https://hackmd.io/_uploads/BkVxtmm_xe.png[]
image:https://hackmd.io/_uploads/HJNWFQQOgg.png[]

|{counter:srn}|
[.text-justify]
接下來我們要加入自定的Playbook，這個Playbook會在事件發生時觸發，並執行oc inspect。蒐集需要的檔案。


|*Action:*
[.text-justify]
Create new playbook for oc adm inspect

image:https://hackmd.io/_uploads/HJkjidtJT.png[]
image:https://hackmd.io/_uploads/Bk6siOt1T.png[]

Clone event-driven-ansible repo in your VScode terminal
[source,shell]
----
cd ~
git clone https://gitea.apps.cluster-7f74v.7f74v.sandbox734.opentlc.com/lab-user/event-driven-ansible.git
----

image:https://hackmd.io/_uploads/B1TgHeXuxx.png[]

Under event-driven-ansible/automation_controller create playbook `oc-inspect.yml`
image:https://hackmd.io/_uploads/ry3mHx7_eg.png[]
填入以下內容
[source,shell]
----
- name: oc adm inspect
  hosts: bastion
  gather_facts: no
  vars:
    ns: "{{ ansible_eda.event.resource.metadata.namespace }}"

  tasks:
    - name: Create inspect file
      shell:
         "oc adm inspect ns/{{ ns }} --kubeconfig /home/lab-user/.kube/config"
      register: lsout
----

push git project
[source,shell]
----
cd ~/event-driven-ansible
git add *
git commit -am "playbook for oc adm inspect"
git push
----

VScode will ask you to login to gittea.
image:https://hackmd.io/_uploads/SkdewgXdlg.png[]


After push completed, Check your commit ID.
image:https://hackmd.io/_uploads/BJ65w0Gdeg.jpg[]

|{counter:srn}|
[.text-justify]
推送新增的腳本後，我們回到AAP的主要頁面，針對剛剛的腳本設定一個新的Job Template。
|*Action:*
[.text-justify]

更新AAP Project

image:https://hackmd.io/_uploads/BkoswCzOlg.jpg[]

新增template取名為 `oc-inspect` 

image:https://hackmd.io/_uploads/S11ydRfOlg.jpg[]

填入對應的內容
image:https://hackmd.io/_uploads/rkOO_CfOee.jpg[]
一定要勾選Prompt on launch，這樣才能在EDA觸發時，帶入變數到playbook內。


|{counter:srn}|
[.text-justify]
完成Template後，我們要設定EDA的Rulebook，讓EDA能夠觸發Job Template。
|*Action:*
[.text-justify]

On Vscode console, switch to eda-rulebooks/rulebooks
and create a file named `oc-inspect.yml`

image:https://hackmd.io/_uploads/rJhIIeQ_ee.png[]


Edit oc-inspect.yml with following 

[source,shell]
----
---
- name: Listen for unhealthy+warning event
  hosts: all
  sources:
    - sabre1041.eda.k8s:
        api_version: v1
        kind: Event
        namespace: eda-demo #自行替換成新預計的ns名稱
  rules:
    - name: Debug
      condition: 
        event.resource.reason == "Unhealthy" and event.resource.type == "Warning"
      throttle:
        once_within: 5 minutes
        group_by_attributes:
          - event.resource.metadata.namespace
          - event.resource.involvedObject.name
      action:
        run_job_template:
          name: oc-inspect #必須對應AAP內的template 名稱
          organization: Default
----

#### Commit and push your rulebook
In the vscode terminal

```bash=
cd ~/eda-rulebooks
git add *
git commit -am "rulebook for oc adm inspect"
git push
```

VScode will ask you to login to gittea.
image:https://hackmd.io/_uploads/SkdewgXdlg.png[]


*Create Rulebook Activation in AAP*
Sync-Rulebook project again

image:https://hackmd.io/_uploads/rkQ4uemdlg.png[]

Click `Create rulebook activation` 

image:https://hackmd.io/_uploads/BJjWOgQ_ll.png[]

Select and fill like following example
image:https://hackmd.io/_uploads/Bk7qOxmulg.png[]

After that you can see your rule is activated
image:https://hackmd.io/_uploads/r1kndxmOel.png[]


|{counter:srn}|
[.text-justify]
我們可以部屬一個新的應用程式，並故意讓它的健康狀態變成 Unhealthy,這樣就可以觸發 EDA 的 Rulebook。
|*Action:*
[.text-justify]

On you VScode terminal, create a new project and deploy a pod with liveness probe.
```
oc new-project eda-demo
```

[source,shell]
----
cat << EOF \| oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    securityContext:
      allowPrivilegeEscalation: false
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop:
        - ALL
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    image: k8s.gcr.io/busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
EOF
----

image:https://hackmd.io/_uploads/ryGBC_typ.png[]

image:https://hackmd.io/_uploads/rkbtCOKy6.png[]


等待40秒後，驗證inspect是否成功

image:https://hackmd.io/_uploads/HkHPeYY16.png[]

image:https://hackmd.io/_uploads/SJBulFYJ6.png[]


|{counter:srn}|
[.text-justify]
=== Lab 5 - EDA Gemini AI 分析問題
[.text-justify]
接下來我們要實作透過EDA串接Gemini AI,讓EDA能夠在事件發生時,透過Gemini AI來分析問題。
|*Action:*

[On Bastion or your VScode terminal] Install Gemini-CLI 

(如果上一場workshop已經安裝過，可以跳安裝Gemini-CLI以及Node.JS的步驟, 但仍需要設定API-KEY以及MCP Server的設定)

Install Node.JS
[source,shell]
----
# Download and install nvm:
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh \| bash
# in lieu of restarting the shell
\. "$HOME/.nvm/nvm.sh"
# Download and install Node.js:
nvm install 22

# Verify the Node.js version:
node -v 
nvm current 

# Verify npm version:
npm -v 
----

Install Gemini-CLI
[source,shell]
----
npm install -g @google/gemini-cli
----

上一場Workshop中已經將Gemini-API Key存放在 `~/tamday/.gemini/.env` 內. 
如果你要使用自己的API-KEY,請前往 
https://aistudio.google.com/app/apikey 
image:https://hackmd.io/_uploads/Hk-hX7kPgg.png[]
[source,shell]
----

cat ~/tamday/.gemini/.env \| grep GEMINI_API_KEY

export GEMINI_API_KEY="<你的API-KEY>"
echo 'export GEMINI_API_KEY="<你的API-KEY>"' >> ~/.bashrc
----

Edit Gemini setting
[source,shell]
----
mkdir .gemini
vi ~/.gemini/settings.json

{
  "theme": "GitHub",
  "mcpServers": {
    "kubernetes": {
      "command": "npx",
      "args": [
        "-y",
        "rh-tam-kubernetes-mcp-server@latest"
      ]
    }
  }
}
----

|{counter:srn}|
[.text-justify]
Bastion安裝完成後,我們要在EDA的Playbook中加入Gemini的API呼叫。讓Gemini能夠在EDA觸發時分析指定namespace的問題。
|*Action:*

於VScode 專案路徑event-driven-ansible/automation_controller底下新增`gemini-analyze.yml`
image:https://hackmd.io/_uploads/HkH_J-QOeg.png[]


[source,shell]
----
- name: Run gemini to troubleshoot given NS
  hosts: bastion
  gather_facts: no
  vars:
    ns: "{{ ansible_eda.event.resource.metadata.namespace }}"

  tasks:
    - name: Gemini analyze NS
      shell: 'gemini -p "分析目前OpenShift內namespace {{ ns }} 有什麼異常 (只需要重點整理，不顯示推論過程)"'
      register: lsout
    - name: Show command output
      debug:
        var: lsout.stdout_lines
----

於Vscode Terminal
[source,shell]
---
cd ~/event-driven-ansible
git add *
git commit -am "Add gemini_analyze playbook"
git push
---

Resync Template project
image:https://hackmd.io/_uploads/rJy1Rg7dgl.png[]

Create a new Template called gemini-analyze
image:https://hackmd.io/_uploads/SkO-AeXdxg.png[]

image:https://hackmd.io/_uploads/SkoBlZ7_lx.jpg[]

|{counter:srn}|
[.text-justify]
編寫Rulebook (設定觸發後搜集oc inspect並讓gemini分析問題)
|*Action:*
於VScode 專案路徑eda-rulebooks/rulebooks底下新增`oc-inspect-analyze.yml`
image:https://hackmd.io/_uploads/rkpchxXuel.png[]

[source,shell]
----
---
- name: Listen for unhealthy+warning event
  hosts: all
  sources:
    - sabre1041.eda.k8s:
        api_version: v1
        kind: Event
        namespace: eda-demo #自行替換成新預計的ns名稱
  rules:
    - name: Debug
      condition: 
        event.resource.reason == "Unhealthy" and event.resource.type == "Warning"
      throttle:
        once_within: 5 minutes
        group_by_attributes:
          - event.resource.metadata.namespace
          - event.resource.involvedObject.name
      actions:
        - run_job_template:
            name: oc-inspect #必須對應AAP內的template 名稱
            organization: Default
        - run_job_template:
            name: gemini-analyze
            organization: Default
----


[source,shell]
----
cd ~/eda-rulebooks
git add *
git commit -am "add inspect_analyze rulebook"
git push
----

Sync-Rulebook project again

image:https://hackmd.io/_uploads/rkQ4uemdlg.png[]

Create new rule activation
image:https://hackmd.io/_uploads/HJt_b-7uxg.png[]

image:https://hackmd.io/_uploads/SkZ0WW7dll.jpg[]

You should see this new rule is activated
image:https://hackmd.io/_uploads/rJs-fWQugg.png[]


Disable the previous role - oc-inspect

image:https://hackmd.io/_uploads/rJn_XbmOgl.png[]
image:https://hackmd.io/_uploads/Bky5XbX_eg.jpg[]


Let's deploy the pod again to trigger the event.
[source,shell]
----
oc delete pod liveness-exec --force

cat << EOF \| oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    securityContext:
      allowPrivilegeEscalation: false
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop:
        - ALL
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    image: k8s.gcr.io/busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
EOF
----

After a while, you should see the job inspect and gemini-analyze was triggered in a role.
image:https://hackmd.io/_uploads/Sk1pmbQdex.png[]

image:https://hackmd.io/_uploads/BkRzVXQdlg.jpg[]


|{counter:srn}|
[.text-justify]
=== Lab 6 - EDA Gemini AI 總結問題並 create support case
|*Action:*

設定環境 
- 取得 Red Hat API Tokens
- 設定 bastion 環境
[source,shell]
----
echo 'export RH_PORTAL_TOKEN="<你的RH-API-TOKEN>"' >> ~/.bashrc
----

創建 playbook
- 創建 automation_controller/oc-inspect-create-case.yml 
[source,shell]
----
- name: Run gemini to troubleshoot given NS
  hosts: bastion
  gather_facts: no
  vars:
    ns: "{{ ansible_eda.event.resource.metadata.namespace }}"

  tasks:
    - name: Create inspect file
      shell:
         "oc adm inspect ns/{{ ns }} --dest-dir=./inspect.local.{{ ns }} --kubeconfig /home/lab-user/.kube/config"
      register: inspect_file
    - name: Compress with tar
      command: "tar -czf inspect.local.{{ ns }}.tar.gz inspect.local.{{ ns }}"
      when: inspect_file.rc == 0
    - name: Gemini analyze NS
      shell: 'gemini -p "分析目前OpenShift內namespace {{ ns }} 有什麼異常 (只需要單行重點整理，不顯示推論過程)"'
      register: lsout
    - name: Show command output
      debug:
        var: lsout.stdout_lines
    - name: create support case
      shell: 'gemini -p "開一個 OCP support case, 標題是[test case] My pod crashed last night, I was wondering about RCA, 描述為 {{lsout.stdout_lines}}，並且將檔案 inspect.local.{{ ns }}.tar.gz 上傳為附件"'
      register: case_output
    - name: show create case result
      debug:
        var: case_output
----

- push git project

[source,shell]
----
cd ~/event-driven-ansible
git add *
git commit -am "playbook for oc adm inspect and create case"
git push
----

- sync project 
image:https://hackmd.io/_uploads/BJYDwHmOll.png[]

- create job template
image:https://hackmd.io/_uploads/SJqEPB7_le.png[]

創建 rulebook 

- playbook

[source,shell]
----
vi ~/eda-rulebooks/rulebooks/oc_inspect_support_case.yml

---
- name: Listen for unhealthy+warning event
  hosts: all
  sources:
    - sabre1041.eda.k8s:
        api_version: v1
        kind: Event
        namespace: eda-demo #自行替換成新預計的ns名稱
  rules:
    - name: Debug
      condition: 
        event.resource.reason == "Unhealthy" and event.resource.type == "Warning"
      throttle:
        once_within: 5 minutes
        group_by_attributes:
          - event.resource.metadata.namespace
          - event.resource.involvedObject.name
      actions:
        - run_job_template:
            name: oc-inspect-create-case
            organization: Default
----

- 上傳

[source,shell]
----
cd ~/eda-rulebooks/
git add .
git commit -m "add oc inspect create support case rulebook"
git push
----

- sync project 

image:https://hackmd.io/_uploads/Sk29wBmOge.png[]

- create rulebook activation

image:https://hackmd.io/_uploads/B13kdBmOgg.png[]

測試

[source,shell]
----
oc delete pod liveness-exec --force

cat << EOF \| oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    securityContext:
      allowPrivilegeEscalation: false
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop:
        - ALL
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    image: k8s.gcr.io/busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
EOF
----

image:https://hackmd.io/_uploads/H1xpbI7dxx.png[]

image::case_created.png[]

- 最後，請記得將 Pod 刪除以及將 Case 關閉，避免持續重複開 Case 以及 Gemini API 使用超過日額。 

|====

== Resources

* Get Red Hat API Token
** link:https://access.redhat.com/management/api[Get Red Hat API Token]
https://access.redhat.com/management/api
